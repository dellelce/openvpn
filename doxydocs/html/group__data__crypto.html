<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>OpenVPN: Data Channel Crypto module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVPN
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">Data Channel Crypto module</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrypto__options.html">crypto_options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga531ce54a40ba4525b7ef859ef7425a38"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__crypto.html#ga531ce54a40ba4525b7ef859ef7425a38">DECRYPT_KEY_ENABLED</a>(multi,  ks)&#160;&#160;&#160;((ks)-&gt;state &gt;= (<a class="el" href="group__control__processor.html#ga66bd0f7cdbc8450a4690c519de7d75bc">S_GOT_KEY</a> - (multi)-&gt;opt.server))</td></tr>
<tr class="separator:ga531ce54a40ba4525b7ef859ef7425a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for performing security operations on data channel packets</h2></td></tr>
<tr class="memitem:ga2756bad88224b98719d4e8f08cb11ef9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__crypto.html#ga2756bad88224b98719d4e8f08cb11ef9">openvpn_encrypt</a> (struct <a class="el" href="structbuffer.html">buffer</a> *buf, struct <a class="el" href="structbuffer.html">buffer</a> work, struct <a class="el" href="structcrypto__options.html">crypto_options</a> *opt)</td></tr>
<tr class="separator:ga2756bad88224b98719d4e8f08cb11ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae91d99446478fcf3327672eb78ef0bf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__crypto.html#gae91d99446478fcf3327672eb78ef0bf8">openvpn_decrypt</a> (struct <a class="el" href="structbuffer.html">buffer</a> *buf, struct <a class="el" href="structbuffer.html">buffer</a> work, struct <a class="el" href="structcrypto__options.html">crypto_options</a> *opt, const struct <a class="el" href="structframe.html">frame</a> *<a class="el" href="structframe.html">frame</a>, const uint8_t *ad_start)</td></tr>
<tr class="separator:gae91d99446478fcf3327672eb78ef0bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for managing security parameter state for data channel packets</h2></td></tr>
<tr class="memitem:gab1369f42e94bbec108d952d565b0f283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__crypto.html#gab1369f42e94bbec108d952d565b0f283">tls_pre_decrypt_lite</a> (const struct <a class="el" href="structtls__auth__standalone.html">tls_auth_standalone</a> *tas, const struct <a class="el" href="structlink__socket__actual.html">link_socket_actual</a> *from, const struct <a class="el" href="structbuffer.html">buffer</a> *buf)</td></tr>
<tr class="separator:gab1369f42e94bbec108d952d565b0f283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba03eaba587a89c2abda8780da7b3ac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__crypto.html#gaba03eaba587a89c2abda8780da7b3ac7">tls_pre_encrypt</a> (struct <a class="el" href="structtls__multi.html">tls_multi</a> *multi, struct <a class="el" href="structbuffer.html">buffer</a> *buf, struct <a class="el" href="structcrypto__options.html">crypto_options</a> **opt)</td></tr>
<tr class="separator:gaba03eaba587a89c2abda8780da7b3ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac2b3aa2c842a102804be65f28adf4b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__crypto.html#gaac2b3aa2c842a102804be65f28adf4b1">tls_prepend_opcode_v1</a> (const struct <a class="el" href="structtls__multi.html">tls_multi</a> *multi, struct <a class="el" href="structbuffer.html">buffer</a> *buf)</td></tr>
<tr class="separator:gaac2b3aa2c842a102804be65f28adf4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad27b20736f89d38d0d2e0c2e35f7a0e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__crypto.html#gad27b20736f89d38d0d2e0c2e35f7a0e3">tls_prepend_opcode_v2</a> (const struct <a class="el" href="structtls__multi.html">tls_multi</a> *multi, struct <a class="el" href="structbuffer.html">buffer</a> *buf)</td></tr>
<tr class="separator:gad27b20736f89d38d0d2e0c2e35f7a0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f2ecd39b88da77b2f8067962155ea82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__crypto.html#ga1f2ecd39b88da77b2f8067962155ea82">tls_post_encrypt</a> (struct <a class="el" href="structtls__multi.html">tls_multi</a> *multi, struct <a class="el" href="structbuffer.html">buffer</a> *buf)</td></tr>
<tr class="separator:ga1f2ecd39b88da77b2f8067962155ea82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section user"><dt>Crypto packet formats</dt><dd>The Data Channel Crypto module supports a number of crypto modes and configurable options. The actual packet format depends on these options. A Data Channel packet can consist of:<ul>
<li><b>Opcode</b>, one byte specifying the packet type (see Network protocol).</li>
<li><b>Peer-id</b>, if using the v2 data channel packet format (see Network protocol).</li>
<li><b>HMAC</b>, covering the ciphertext IV + ciphertext. The HMAC size depends on the <code>--auth</code> option. If <code>--auth</code> <code>none</code> is specified, there is no HMAC at all.</li>
<li><b>Ciphertext</b> <b>IV</b>. The IV size depends on the <code>--cipher</code> option.</li>
<li><b>Packet</b> <b>ID</b>, a 32-bit incrementing packet counter that provides replay protection (if not disabled by <code>--no-replay</code>).</li>
<li><b>Timestamp</b>, a 32-bit timestamp of the current time.</li>
<li><b>Payload</b>, the plain text network packet to be encrypted (unless encryption is disabled by using <code>--cipher</code> <code>none</code>). The payload might already be compressed (see Compression module).</li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>This section does not discuss the opcode and peer-id, since those do not depend on the data channel crypto. See Network protocol for more information on those.</dd></dl>
<dl class="section user"><dt></dt><dd><em>Legenda</em> <br />
<code>[ xxx ]</code> = unprotected <br />
<code>[ - xxx - ]</code> = authenticated <br />
<code>[ * xxx * ]</code> = encrypted and authenticated</dd></dl>
<dl class="section user"><dt></dt><dd><b>CBC data channel cypto format</b> <br />
In CBC mode, both TLS-mode and static key mode are supported. The IV consists of random bits to provide unpredictable IVs. <br />
<em>CBC IV format:</em> <br />
<code> [ - random - ] </code> <br />
<em>CBC data channel crypto format in TLS-mode:</em> <br />
<code> [ HMAC ] [ - IV - ] [ * packet ID * ] [ * packet payload * ] </code> <br />
<em>CBC data channel crypto format in static key mode:</em> <br />
<code> [ HMAC ] [ - IV - ] [ * packet ID * ] [ * timestamp * ] [ * packet payload * ] </code></dd></dl>
<dl class="section user"><dt></dt><dd><b>CFB/OFB data channel crypto format</b> <br />
CFB and OFB modes are only supported in TLS mode. In these modes, the IV consists of the packet counter and a timestamp. If the IV is more than 8 bytes long, the remaining space is filled with zeroes. The packet counter may not roll over within a single TLS sessions. This results in a unique IV for each packet, as required by the CFB and OFB cipher modes.</dd></dl>
<dl class="section user"><dt></dt><dd><em>CFB/OFB IV format:</em> <br />
<code> [ - packet ID - ] [ - timestamp - ] [ - opt: zero-padding - ] </code><br />
<em>CFB/OFB data channel crypto format:</em> <br />
<code> [ HMAC ] [ - IV - ] [ * packet payload * ] </code></dd></dl>
<dl class="section user"><dt></dt><dd><b>GCM data channel crypto format</b> <br />
GCM modes are only supported in TLS mode. In these modes, the IV consists of the 32-bit packet counter followed by data from the HMAC key. The HMAC key can be used as IV, since in GCM and CCM modes the HMAC key is not used for the HMAC. The packet counter may not roll over within a single TLS sessions. This results in a unique IV for each packet, as required by GCM.</dd></dl>
<dl class="section user"><dt></dt><dd>The HMAC key data is pre-shared during the connection setup, and thus can be omitted in on-the-wire packets, saving 8 bytes per packet (for GCM and CCM).</dd></dl>
<dl class="section user"><dt></dt><dd>In GCM mode, P_DATA_V2 headers (the opcode and peer-id) are also authenticated as Additional Data.</dd></dl>
<dl class="section user"><dt></dt><dd><em>GCM IV format:</em> <br />
<code> [ - packet ID - ] [ - HMAC key data - ] </code><br />
<em>P_DATA_V1 GCM data channel crypto format:</em> <br />
<code> [ opcode ] [ - packet ID - ] [ TAG ] [ * packet payload * ] </code> <em>P_DATA_V2 GCM data channel crypto format:</em> <br />
<code> [ - opcode/peer-id - ] [ - packet ID - ] [ TAG ] [ * packet payload * ] </code></dd></dl>
<dl class="section user"><dt></dt><dd><b>No-crypto data channel format</b> <br />
In no-crypto mode (<code>--cipher</code> <code>none</code> is specified), both TLS-mode and static key mode are supported. No encryption will be performed on the packet, but packets can still be authenticated. This mode does not require an IV.<br />
<em>No-crypto data channel crypto format in TLS-mode:</em> <br />
<code> [ HMAC ] [ - packet ID - ] [ - packet payload - ] </code> <br />
<em>No-crypto data channel crypto format in static key mode:</em> <br />
<code> [ HMAC ] [ - packet ID - ] [ - timestamp - ] [ - packet payload - ] </code> </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga531ce54a40ba4525b7ef859ef7425a38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DECRYPT_KEY_ENABLED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">multi, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ks&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((ks)-&gt;state &gt;= (<a class="el" href="group__control__processor.html#ga66bd0f7cdbc8450a4690c519de7d75bc">S_GOT_KEY</a> - (multi)-&gt;opt.server))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether the <em>ks</em> <code><a class="el" href="structkey__state.html">key_state</a></code> is ready to receive data channel packets.</p>
<p>If true, it is safe to assume that this session has been authenticated by TLS.</p>
<dl class="section note"><dt>Note</dt><dd>This macro only works if S_SENT_KEY + 1 == S_GOT_KEY. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae91d99446478fcf3327672eb78ef0bf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> openvpn_decrypt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcrypto__options.html">crypto_options</a> *&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structframe.html">frame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>ad_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HMAC verify and decrypt a data channel packet received from a remote OpenVPN peer.</p>
<p>This function handles authenticating and decrypting a data channel packet received from a remote OpenVPN peer. It receives the necessary security parameters in the <em>opt</em> argument, which should have been set to the correct values by the <code><a class="el" href="ssl_8c.html#ad436aa1372a562e8be84491907531df4">tls_pre_decrypt()</a></code> function.</p>
<p>This function calls the <code>EVP_Cipher*</code> and <code>HMAC_*</code> functions of the OpenSSL library to perform the actual security operations.</p>
<p>If an error occurs during processing, then the <em>buf</em> buffer is set to empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- The buffer containing the packet received from a remote OpenVPN peer on which to perform security operations. </td></tr>
    <tr><td class="paramname">work</td><td>- A working buffer. </td></tr>
    <tr><td class="paramname">opt</td><td>- The security parameter state for this VPN tunnel. </td></tr>
    <tr><td class="paramname">frame</td><td>- The packet geometry parameters for this VPN tunnel. </td></tr>
    <tr><td class="paramname">ad_start</td><td>- A pointer into buf, indicating from where to start authenticating additional data (AEAD mode only).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if the packet was authenticated and decrypted successfully. </li>
<li>False, if an error occurred. <br />
 On return, the <em>buf</em> argument will point to the resulting buffer. This buffer will either contain the plaintext packet ready for further processing, or be empty if an error occurred. </li>
</ul>
</dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data__crypto_gae91d99446478fcf3327672eb78ef0bf8_cgraph.png" border="0" usemap="#group__data__crypto_gae91d99446478fcf3327672eb78ef0bf8_cgraph" alt=""/></div>
<map name="group__data__crypto_gae91d99446478fcf3327672eb78ef0bf8_cgraph" id="group__data__crypto_gae91d99446478fcf3327672eb78ef0bf8_cgraph">
<area shape="rect" id="node2" href="crypto__backend_8h.html#a21c134671c60f2bc399a5b5a76d7e084" title="cipher_kt_mode_aead" alt="" coords="181,5,330,32"/>
<area shape="rect" id="node3" href="crypto__backend_8h.html#a56d0dd0253f889a5305beb86d2900fe7" title="cipher_ctx_get_cipher_kt" alt="" coords="172,56,339,83"/>
</map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data__crypto_gae91d99446478fcf3327672eb78ef0bf8_icgraph.png" border="0" usemap="#group__data__crypto_gae91d99446478fcf3327672eb78ef0bf8_icgraph" alt=""/></div>
<map name="group__data__crypto_gae91d99446478fcf3327672eb78ef0bf8_icgraph" id="group__data__crypto_gae91d99446478fcf3327672eb78ef0bf8_icgraph">
<area shape="rect" id="node2" href="crypto_8h.html#a3c572ced6eea1c2b933df8e82b848983" title="test_crypto" alt="" coords="206,5,293,32"/>
<area shape="rect" id="node4" href="forward_8h.html#a01bb4da24c0d75c32845ac87c5cad055" title="process_incoming_link\l_part1" alt="" coords="172,57,327,98"/>
<area shape="rect" id="node3" href="options_8h.html#a599fd786973efc7acefb11fe4ae74180" title="show_settings" alt="" coords="375,5,480,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga2756bad88224b98719d4e8f08cb11ef9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void openvpn_encrypt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcrypto__options.html">crypto_options</a> *&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encrypt and HMAC sign a packet so that it can be sent as a data channel VPN tunnel packet to a remote OpenVPN peer.</p>
<p>This function handles encryption and HMAC signing of a data channel packet before it is sent to its remote OpenVPN peer. It receives the necessary security parameters in the <em>opt</em> argument, which should have been set to the correct values by the <code><a class="el" href="group__data__crypto.html#gaba03eaba587a89c2abda8780da7b3ac7">tls_pre_encrypt()</a></code> function.</p>
<p>This function calls the <code>EVP_Cipher*</code> and <code>HMAC_*</code> functions of the OpenSSL library to perform the actual security operations.</p>
<p>If an error occurs during processing, then the <em>buf</em> buffer is set to empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- The buffer containing the packet on which to perform security operations. </td></tr>
    <tr><td class="paramname">work</td><td>- An initialized working buffer. </td></tr>
    <tr><td class="paramname">opt</td><td>- The security parameter state for this VPN tunnel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns void.<br />
 On return, the <em>buf</em> argument will point to the resulting buffer. This buffer will either contain the processed packet ready for sending, or be empty if an error occurred. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data__crypto_ga2756bad88224b98719d4e8f08cb11ef9_cgraph.png" border="0" usemap="#group__data__crypto_ga2756bad88224b98719d4e8f08cb11ef9_cgraph" alt=""/></div>
<map name="group__data__crypto_ga2756bad88224b98719d4e8f08cb11ef9_cgraph" id="group__data__crypto_ga2756bad88224b98719d4e8f08cb11ef9_cgraph">
<area shape="rect" id="node2" href="crypto__backend_8h.html#a56d0dd0253f889a5305beb86d2900fe7" title="cipher_ctx_get_cipher_kt" alt="" coords="172,5,339,32"/>
<area shape="rect" id="node3" href="crypto__backend_8h.html#a21c134671c60f2bc399a5b5a76d7e084" title="cipher_kt_mode_aead" alt="" coords="181,56,330,83"/>
</map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data__crypto_ga2756bad88224b98719d4e8f08cb11ef9_icgraph.png" border="0" usemap="#group__data__crypto_ga2756bad88224b98719d4e8f08cb11ef9_icgraph" alt=""/></div>
<map name="group__data__crypto_ga2756bad88224b98719d4e8f08cb11ef9_icgraph" id="group__data__crypto_ga2756bad88224b98719d4e8f08cb11ef9_icgraph">
<area shape="rect" id="node2" href="crypto_8h.html#a3c572ced6eea1c2b933df8e82b848983" title="test_crypto" alt="" coords="177,20,263,47"/>
<area shape="rect" id="node4" href="forward_8h.html#a66abf1cd0cfe2af99b61d954cab37966" title="encrypt_sign" alt="" coords="172,85,268,112"/>
<area shape="rect" id="node3" href="options_8h.html#a599fd786973efc7acefb11fe4ae74180" title="show_settings" alt="" coords="349,5,454,32"/>
<area shape="rect" id="node5" href="forward_8h.html#a1ac8de3ee1c24f16d30a8773d7574bee" title="process_incoming_tun" alt="" coords="325,56,477,83"/>
<area shape="rect" id="node7" href="occ_8c.html#aa2d19601aa35014bd3c32bbac4eaeab7" title="check_send_occ_msg\l_dowork" alt="" coords="325,107,477,149"/>
<area shape="rect" id="node8" href="ping_8c.html#a4b45bd434660f2737f39189105c0604f" title="check_ping_send_dowork" alt="" coords="316,173,487,200"/>
<area shape="rect" id="node6" href="forward_8h.html#a20db9c6797042b6584e95af8ea5bbc10" title="process_io" alt="" coords="535,56,620,83"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga1f2ecd39b88da77b2f8067962155ea82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tls_post_encrypt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtls__multi.html">tls_multi</a> *&#160;</td>
          <td class="paramname"><em>multi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform some accounting for the key state used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multi</td><td>- The TLS state for this packet's destination VPN tunnel. </td></tr>
    <tr><td class="paramname">buf</td><td>- The buffer containing the outgoing packet. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data__crypto_ga1f2ecd39b88da77b2f8067962155ea82_icgraph.png" border="0" usemap="#group__data__crypto_ga1f2ecd39b88da77b2f8067962155ea82_icgraph" alt=""/></div>
<map name="group__data__crypto_ga1f2ecd39b88da77b2f8067962155ea82_icgraph" id="group__data__crypto_ga1f2ecd39b88da77b2f8067962155ea82_icgraph">
<area shape="rect" id="node2" href="forward_8h.html#a66abf1cd0cfe2af99b61d954cab37966" title="encrypt_sign" alt="" coords="172,64,268,91"/>
<area shape="rect" id="node3" href="forward_8h.html#a1ac8de3ee1c24f16d30a8773d7574bee" title="process_incoming_tun" alt="" coords="325,5,477,32"/>
<area shape="rect" id="node5" href="occ_8c.html#aa2d19601aa35014bd3c32bbac4eaeab7" title="check_send_occ_msg\l_dowork" alt="" coords="325,57,477,98"/>
<area shape="rect" id="node6" href="ping_8c.html#a4b45bd434660f2737f39189105c0604f" title="check_ping_send_dowork" alt="" coords="316,123,487,149"/>
<area shape="rect" id="node4" href="forward_8h.html#a20db9c6797042b6584e95af8ea5bbc10" title="process_io" alt="" coords="535,5,620,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gab1369f42e94bbec108d952d565b0f283"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> tls_pre_decrypt_lite </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structtls__auth__standalone.html">tls_auth_standalone</a> *&#160;</td>
          <td class="paramname"><em>tas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlink__socket__actual.html">link_socket_actual</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inspect an incoming packet for which no VPN tunnel is active, and determine whether a new VPN tunnel should be created.</p>
<p>This function receives the initial incoming packet from a client that wishes to establish a new VPN tunnel, and determines the packet is a valid initial packet. It is only used when OpenVPN is running in server mode.</p>
<p>The tests performed by this function are whether the packet's opcode is correct for establishing a new VPN tunnel, whether its key ID is 0, and whether its size is not too large. This function also performs the initial HMAC firewall test, if configured to do so.</p>
<p>The incoming packet and the local VPN tunnel state are not modified by this function. Its sole purpose is to inspect the packet and determine whether a new VPN tunnel should be created. If so, that new VPN tunnel instance will handle processing of the packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tas</td><td>- The standalone TLS authentication setting structure for this process. </td></tr>
    <tr><td class="paramname">from</td><td>- The source address of the packet. </td></tr>
    <tr><td class="paramname">buf</td><td>- A buffer structure containing the incoming packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True if the packet is valid and a new VPN tunnel should be created for this client. </li>
<li>False if the packet is not valid, did not pass the HMAC firewall test, or some other error occurred. </li>
</ul>
</dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data__crypto_gab1369f42e94bbec108d952d565b0f283_cgraph.png" border="0" usemap="#group__data__crypto_gab1369f42e94bbec108d952d565b0f283_cgraph" alt=""/></div>
<map name="group__data__crypto_gab1369f42e94bbec108d952d565b0f283_cgraph" id="group__data__crypto_gab1369f42e94bbec108d952d565b0f283_cgraph">
<area shape="rect" id="node2" href="socket_8c.html#aefe5013514f1d62a138107fb43cc74e3" title="print_link_socket_actual" alt="" coords="188,81,351,108"/>
<area shape="rect" id="node10" href="buffer_8c.html#a24af27c1066ce2acc17cf77a278e051d" title="clone_buf" alt="" coords="231,132,308,159"/>
<area shape="rect" id="node11" href="buffer_8c.html#a11cd36c0af3073bd1245bbed1cca9590" title="free_buf" alt="" coords="236,183,303,209"/>
<area shape="rect" id="node12" href="ssl__backend_8h.html#a163fa38939865554f4d7160a0e426b17" title="tls_clear_error" alt="" coords="217,233,321,260"/>
<area shape="rect" id="node3" href="socket_8c.html#aa401d7e395acdc1d4f61f6526ef92846" title="print_link_socket_actual_ex" alt="" coords="399,81,581,108"/>
<area shape="rect" id="node4" href="buffer_8c.html#aa35bf7feb6a99bf5d364b2d4eba1195c" title="alloc_buf_gc" alt="" coords="805,31,900,57"/>
<area shape="rect" id="node7" href="buffer_8c.html#a3307f08331b1ce42168bafd2ecf7874a" title="buf_printf" alt="" coords="815,132,890,159"/>
<area shape="rect" id="node8" href="socket_8c.html#a616cfadfd81ab5ba341fa3adb1e93788" title="print_sockaddr_ex" alt="" coords="629,81,757,108"/>
<area shape="rect" id="node5" href="buffer_8c.html#acc1a4ee83a591116d331e52baacf253d" title="buf_size_error" alt="" coords="948,5,1051,32"/>
<area shape="rect" id="node6" href="buffer_8c.html#a67f7dec7f86e113dc0744584fd80b621" title="gc_malloc" alt="" coords="959,56,1040,83"/>
<area shape="rect" id="node9" href="buffer_8c.html#a3856237f6bda0d132ed555c23f3b8968" title="buf_puts" alt="" coords="817,81,888,108"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaba03eaba587a89c2abda8780da7b3ac7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tls_pre_encrypt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtls__multi.html">tls_multi</a> *&#160;</td>
          <td class="paramname"><em>multi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcrypto__options.html">crypto_options</a> **&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Choose the appropriate security parameters with which to process an outgoing packet.</p>
<p>If no appropriate security parameters can be found, or if some other error occurs, then the buffer is set to empty, and the parameters to a NULL pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multi</td><td>- The TLS state for this packet's destination VPN tunnel. </td></tr>
    <tr><td class="paramname">buf</td><td>- The buffer containing the outgoing packet. </td></tr>
    <tr><td class="paramname">opt</td><td>- Returns a crypto options structure with the security parameters. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data__crypto_gaba03eaba587a89c2abda8780da7b3ac7_icgraph.png" border="0" usemap="#group__data__crypto_gaba03eaba587a89c2abda8780da7b3ac7_icgraph" alt=""/></div>
<map name="group__data__crypto_gaba03eaba587a89c2abda8780da7b3ac7_icgraph" id="group__data__crypto_gaba03eaba587a89c2abda8780da7b3ac7_icgraph">
<area shape="rect" id="node2" href="forward_8h.html#a66abf1cd0cfe2af99b61d954cab37966" title="encrypt_sign" alt="" coords="164,64,260,91"/>
<area shape="rect" id="node3" href="forward_8h.html#a1ac8de3ee1c24f16d30a8773d7574bee" title="process_incoming_tun" alt="" coords="317,5,469,32"/>
<area shape="rect" id="node5" href="occ_8c.html#aa2d19601aa35014bd3c32bbac4eaeab7" title="check_send_occ_msg\l_dowork" alt="" coords="317,57,469,98"/>
<area shape="rect" id="node6" href="ping_8c.html#a4b45bd434660f2737f39189105c0604f" title="check_ping_send_dowork" alt="" coords="308,123,479,149"/>
<area shape="rect" id="node4" href="forward_8h.html#a20db9c6797042b6584e95af8ea5bbc10" title="process_io" alt="" coords="527,5,612,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaac2b3aa2c842a102804be65f28adf4b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tls_prepend_opcode_v1 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structtls__multi.html">tls_multi</a> *&#160;</td>
          <td class="paramname"><em>multi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepend a one-byte OpenVPN data channel P_DATA_V1 opcode to the packet.</p>
<p>The opcode identifies the packet as a V1 data channel packet and gives the low-permutation version of the key-id to the recipient, so it knows which decrypt key to use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multi</td><td>- The TLS state for this packet's destination VPN tunnel. </td></tr>
    <tr><td class="paramname">buf</td><td>- The buffer to write the header to. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data__crypto_gaac2b3aa2c842a102804be65f28adf4b1_icgraph.png" border="0" usemap="#group__data__crypto_gaac2b3aa2c842a102804be65f28adf4b1_icgraph" alt=""/></div>
<map name="group__data__crypto_gaac2b3aa2c842a102804be65f28adf4b1_icgraph" id="group__data__crypto_gaac2b3aa2c842a102804be65f28adf4b1_icgraph">
<area shape="rect" id="node2" href="forward_8h.html#a66abf1cd0cfe2af99b61d954cab37966" title="encrypt_sign" alt="" coords="211,64,307,91"/>
<area shape="rect" id="node3" href="forward_8h.html#a1ac8de3ee1c24f16d30a8773d7574bee" title="process_incoming_tun" alt="" coords="364,5,516,32"/>
<area shape="rect" id="node5" href="occ_8c.html#aa2d19601aa35014bd3c32bbac4eaeab7" title="check_send_occ_msg\l_dowork" alt="" coords="364,57,516,98"/>
<area shape="rect" id="node6" href="ping_8c.html#a4b45bd434660f2737f39189105c0604f" title="check_ping_send_dowork" alt="" coords="355,123,525,149"/>
<area shape="rect" id="node4" href="forward_8h.html#a20db9c6797042b6584e95af8ea5bbc10" title="process_io" alt="" coords="573,5,659,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gad27b20736f89d38d0d2e0c2e35f7a0e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tls_prepend_opcode_v2 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structtls__multi.html">tls_multi</a> *&#160;</td>
          <td class="paramname"><em>multi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepend an OpenVPN data channel P_DATA_V2 header to the packet. The P_DATA_V2 header consists of a 1-byte opcode, followed by a 3-byte peer-id.</p>
<p>The opcode identifies the packet as a V2 data channel packet and gives the low-permutation version of the key-id to the recipient, so it knows which decrypt key to use.</p>
<p>The peer-id is sent by clients to servers to help the server determine to select the decrypt key when the client is roaming between addresses/ports.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multi</td><td>- The TLS state for this packet's destination VPN tunnel. </td></tr>
    <tr><td class="paramname">buf</td><td>- The buffer to write the header to. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data__crypto_gad27b20736f89d38d0d2e0c2e35f7a0e3_icgraph.png" border="0" usemap="#group__data__crypto_gad27b20736f89d38d0d2e0c2e35f7a0e3_icgraph" alt=""/></div>
<map name="group__data__crypto_gad27b20736f89d38d0d2e0c2e35f7a0e3_icgraph" id="group__data__crypto_gad27b20736f89d38d0d2e0c2e35f7a0e3_icgraph">
<area shape="rect" id="node2" href="forward_8h.html#a66abf1cd0cfe2af99b61d954cab37966" title="encrypt_sign" alt="" coords="211,64,307,91"/>
<area shape="rect" id="node3" href="forward_8h.html#a1ac8de3ee1c24f16d30a8773d7574bee" title="process_incoming_tun" alt="" coords="364,5,516,32"/>
<area shape="rect" id="node5" href="occ_8c.html#aa2d19601aa35014bd3c32bbac4eaeab7" title="check_send_occ_msg\l_dowork" alt="" coords="364,57,516,98"/>
<area shape="rect" id="node6" href="ping_8c.html#a4b45bd434660f2737f39189105c0604f" title="check_ping_send_dowork" alt="" coords="355,123,525,149"/>
<area shape="rect" id="node4" href="forward_8h.html#a20db9c6797042b6584e95af8ea5bbc10" title="process_io" alt="" coords="573,5,659,32"/>
</map>
</div>
</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
