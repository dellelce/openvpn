<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>OpenVPN: Control_tls</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVPN
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">Control_tls</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Control_tls:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__control__tls.png" border="0" alt="" usemap="#group____control____tls"/>
<map name="group____control____tls" id="group____control____tls">
<area shape="rect" id="node1" href="group__tls__crypt.html" title="Control channel encryption\l (&#45;&#45;tls&#45;crypt)" alt="" coords="137,5,313,47"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__tls__crypt"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tls__crypt.html">Control channel encryption (--tls-crypt)</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for packets to be sent to a remote OpenVPN peer</h2></td></tr>
<tr class="memitem:gaa5438c5f4b03dafec41e663a3e5734d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__control__tls.html#gaa5438c5f4b03dafec41e663a3e5734d0">key_state_write_plaintext</a> (struct <a class="el" href="structkey__state__ssl.html">key_state_ssl</a> *ks_ssl, struct <a class="el" href="structbuffer.html">buffer</a> *buf)</td></tr>
<tr class="separator:gaa5438c5f4b03dafec41e663a3e5734d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67dac3b75328d8b92d3f1a69e86dacdc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__control__tls.html#ga67dac3b75328d8b92d3f1a69e86dacdc">key_state_write_plaintext_const</a> (struct <a class="el" href="structkey__state__ssl.html">key_state_ssl</a> *ks_ssl, const uint8_t *data, int len)</td></tr>
<tr class="separator:ga67dac3b75328d8b92d3f1a69e86dacdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7260a351c5bb3bf22628278e09f2f7b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__control__tls.html#ga7260a351c5bb3bf22628278e09f2f7b3">key_state_read_ciphertext</a> (struct <a class="el" href="structkey__state__ssl.html">key_state_ssl</a> *ks_ssl, struct <a class="el" href="structbuffer.html">buffer</a> *buf, int maxlen)</td></tr>
<tr class="separator:ga7260a351c5bb3bf22628278e09f2f7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for packets received from a remote OpenVPN peer</h2></td></tr>
<tr class="memitem:ga5712e1bfbeafff1041a99b57cf4a91f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__control__tls.html#ga5712e1bfbeafff1041a99b57cf4a91f4">key_state_write_ciphertext</a> (struct <a class="el" href="structkey__state__ssl.html">key_state_ssl</a> *ks_ssl, struct <a class="el" href="structbuffer.html">buffer</a> *buf)</td></tr>
<tr class="separator:ga5712e1bfbeafff1041a99b57cf4a91f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5597992eeb64d1be998be0ccf98bf97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__control__tls.html#gae5597992eeb64d1be998be0ccf98bf97">key_state_read_plaintext</a> (struct <a class="el" href="structkey__state__ssl.html">key_state_ssl</a> *ks_ssl, struct <a class="el" href="structbuffer.html">buffer</a> *buf, int maxlen)</td></tr>
<tr class="separator:gae5597992eeb64d1be998be0ccf98bf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Function for authenticating a new connection from a remote OpenVPN peer</h2></td></tr>
<tr class="memitem:gadeac70d67a80b44a96cbde2368dd5f3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__control__tls.html#gadeac70d67a80b44a96cbde2368dd5f3c">verify_callback</a> (void *session_obj, mbedtls_x509_crt *cert, int cert_depth, uint32_t *flags)</td></tr>
<tr class="separator:gadeac70d67a80b44a96cbde2368dd5f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Function for authenticating a new connection from a remote OpenVPN peer</h2></td></tr>
<tr class="memitem:gaf045c97f727aebae9e8fc9852421c4f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__control__tls.html#gaf045c97f727aebae9e8fc9852421c4f3">verify_callback</a> (int preverify_ok, X509_STORE_CTX *ctx)</td></tr>
<tr class="separator:gaf045c97f727aebae9e8fc9852421c4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7260a351c5bb3bf22628278e09f2f7b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int key_state_read_ciphertext </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structkey__state__ssl.html">key_state_ssl</a> *&#160;</td>
          <td class="paramname"><em>ks_ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract ciphertext data from the TLS module.</p>
<p>If the <em>buf</em> buffer has a length other than zero, this function does not perform any action and returns 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks_ssl</td><td>- The security parameter state for this key session. </td></tr>
    <tr><td class="paramname">buf</td><td>- A buffer in which to store the ciphertext. </td></tr>
    <tr><td class="paramname">maxlen</td><td>- The maximum number of bytes to extract.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value indicates whether the data was successfully processed:<ul>
<li><code>1</code>: Data was extracted successfully.</li>
<li><code>0</code>: No data was extracted, this function should be called again later to retry.</li>
<li><code>-1</code>: An error occurred. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae5597992eeb64d1be998be0ccf98bf97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int key_state_read_plaintext </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structkey__state__ssl.html">key_state_ssl</a> *&#160;</td>
          <td class="paramname"><em>ks_ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract plaintext data from the TLS module.</p>
<p>If the <em>buf</em> buffer has a length other than zero, this function does not perform any action and returns 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks_ssl</td><td>- The security parameter state for this key session. </td></tr>
    <tr><td class="paramname">buf</td><td>- A buffer in which to store the plaintext. </td></tr>
    <tr><td class="paramname">maxlen</td><td>- The maximum number of bytes to extract.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value indicates whether the data was successfully processed:<ul>
<li><code>1</code>: Data was extracted successfully.</li>
<li><code>0</code>: No data was extracted, this function should be called again later to retry.</li>
<li><code>-1</code>: An error occurred. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5712e1bfbeafff1041a99b57cf4a91f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int key_state_write_ciphertext </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structkey__state__ssl.html">key_state_ssl</a> *&#160;</td>
          <td class="paramname"><em>ks_ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a ciphertext buffer into the TLS module.</p>
<p>After successfully processing the data, the data in <em>buf</em> is zeroized, its length set to zero, and a value of <code>1</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks_ssl</td><td>- The security parameter state for this key session. </td></tr>
    <tr><td class="paramname">buf</td><td>- The ciphertext message to process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value indicates whether the data was successfully processed:<ul>
<li><code>1</code>: All the data was processed successfully.</li>
<li><code>0</code>: The data was not processed, this function should be called again later to retry.</li>
<li><code>-1</code>: An error occurred. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa5438c5f4b03dafec41e663a3e5734d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int key_state_write_plaintext </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structkey__state__ssl.html">key_state_ssl</a> *&#160;</td>
          <td class="paramname"><em>ks_ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a plaintext buffer into the TLS module.</p>
<p>After successfully processing the data, the data in <em>buf</em> is zeroized, its length set to zero, and a value of <code>1</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks_ssl</td><td>- The security parameter state for this key session. </td></tr>
    <tr><td class="paramname">buf</td><td>- The plaintext message to process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value indicates whether the data was successfully processed:<ul>
<li><code>1</code>: All the data was processed successfully.</li>
<li><code>0</code>: The data was not processed, this function should be called again later to retry.</li>
<li><code>-1</code>: An error occurred. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga67dac3b75328d8b92d3f1a69e86dacdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int key_state_write_plaintext_const </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structkey__state__ssl.html">key_state_ssl</a> *&#160;</td>
          <td class="paramname"><em>ks_ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert plaintext data into the TLS module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks_ssl</td><td>- The security parameter state for this key session. </td></tr>
    <tr><td class="paramname">data</td><td>- A pointer to the data to process. </td></tr>
    <tr><td class="paramname">len</td><td>- The length in bytes of the data to process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value indicates whether the data was successfully processed:<ul>
<li><code>1</code>: All the data was processed successfully.</li>
<li><code>0</code>: The data was not processed, this function should be called again later to retry.</li>
<li><code>-1</code>: An error occurred. </li>
</ul>
</dd></dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__control__tls_ga67dac3b75328d8b92d3f1a69e86dacdc_icgraph.png" border="0" usemap="#group__control__tls_ga67dac3b75328d8b92d3f1a69e86dacdc_icgraph" alt=""/></div>
<map name="group__control__tls_ga67dac3b75328d8b92d3f1a69e86dacdc_icgraph" id="group__control__tls_ga67dac3b75328d8b92d3f1a69e86dacdc_icgraph">
<area shape="rect" id="node2" href="ssl_8h.html#af2bd825809313e721a9f2d219ad59ecd" title="tls_send_payload" alt="" coords="223,13,345,39"/>
<area shape="rect" id="node3" href="forward_8h.html#a7a409db050be184362b60f3ce7b56b35" title="send_control_channel\l_string" alt="" coords="393,5,541,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaf045c97f727aebae9e8fc9852421c4f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int verify_callback </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>preverify_ok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X509_STORE_CTX *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verify that the remote OpenVPN peer's certificate allows setting up a VPN tunnel.</p>
<p>This callback function is called every time a new TLS session is being setup to determine whether the remote OpenVPN peer's certificate is allowed to connect. It is called for once for every certificate in the chain. The callback functionality is configured in the <code><a class="el" href="ssl_8c.html#a5d5e4629bd3c2114b3105bf1f082bc86">init_ssl()</a></code> function, which calls the OpenSSL library's <code>SSL_CTX_set_verify()</code> function with <code><a class="el" href="group__control__tls.html#gaf045c97f727aebae9e8fc9852421c4f3">verify_callback()</a></code> as its callback argument.</p>
<p>It checks preverify_ok, and registers the certificate hash. If these steps succeed, it calls the <code><a class="el" href="ssl__verify_8c.html#a8574f9402b712d3051d9febde91cf220">verify_cert()</a></code> function, which performs OpenVPN-specific verification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preverify_ok</td><td>- Whether the remote OpenVPN peer's certificate past verification. A value of 1 means it verified successfully, 0 means it failed. </td></tr>
    <tr><td class="paramname">ctx</td><td>- The complete context used by the OpenSSL library to verify the certificate chain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value indicates whether the supplied certificate is allowed to set up a VPN tunnel. The following values can be returned:<ul>
<li><code>0</code>: failure, this certificate is not allowed to connect.</li>
<li><code>1</code>: success, this certificate is allowed to connect. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gadeac70d67a80b44a96cbde2368dd5f3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int verify_callback </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>session_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mbedtls_x509_crt *&#160;</td>
          <td class="paramname"><em>cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cert_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verify that the remote OpenVPN peer's certificate allows setting up a VPN tunnel.</p>
<p>This callback function is called when a new TLS session is being setup to determine whether the remote OpenVPN peer's certificate is allowed to connect. It is called for once for every certificate in the chain. The callback functionality is configured in the <code><a class="el" href="ssl__backend_8h.html#a8afed7d8591df5b99475f4503031bb89">key_state_ssl_init()</a></code> function, which calls the mbed TLS library's <code>mbedtls_ssl_conf_verify()</code> function with <code><a class="el" href="group__control__tls.html#gadeac70d67a80b44a96cbde2368dd5f3c">verify_callback()</a></code> as its callback argument.</p>
<p>It checks *flags and registers the certificate hash. If these steps succeed, it calls the <code><a class="el" href="ssl__verify_8c.html#a8574f9402b712d3051d9febde91cf220">verify_cert()</a></code> function, which performs OpenVPN-specific verification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_obj</td><td>- The OpenVPN <code><a class="el" href="structtls__session.html">tls_session</a></code> associated with this object, as set during SSL session setup. </td></tr>
    <tr><td class="paramname">cert</td><td>- The certificate used by mbed TLS. </td></tr>
    <tr><td class="paramname">cert_depth</td><td>- The depth of the current certificate in the chain, with 0 being the actual certificate. </td></tr>
    <tr><td class="paramname">flags</td><td>- Whether the remote OpenVPN peer's certificate passed verification. A value of 0 means it verified successfully, any other value means it failed. <code><a class="el" href="group__control__tls.html#gadeac70d67a80b44a96cbde2368dd5f3c">verify_callback()</a></code> is considered to have ok'ed this certificate if flags is 0 when it returns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is 0 unless a fatal error occurred. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
