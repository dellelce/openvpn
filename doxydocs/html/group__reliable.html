<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>OpenVPN: Reliable</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVPN
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">Reliable</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreliable__ack.html">reliable_ack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreliable__entry.html">reliable_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreliable.html">reliable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gacb891f0bfc023839a53a2c7005cd340c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#gacb891f0bfc023839a53a2c7005cd340c">EXPONENTIAL_BACKOFF</a></td></tr>
<tr class="separator:gacb891f0bfc023839a53a2c7005cd340c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91ccbc389e490d03321b1a6de0dd096d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga91ccbc389e490d03321b1a6de0dd096d">RELIABLE_ACK_SIZE</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ga91ccbc389e490d03321b1a6de0dd096d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa626a13dc31bf131a92548b9b2810cba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#gaa626a13dc31bf131a92548b9b2810cba">RELIABLE_CAPACITY</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:gaa626a13dc31bf131a92548b9b2810cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for processing incoming acknowledgments</h2></td></tr>
<tr class="memitem:ga03d3c93ec4c15d57947740a56eae0aec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga03d3c93ec4c15d57947740a56eae0aec">reliable_ack_read</a> (struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *ack, struct <a class="el" href="structbuffer.html">buffer</a> *buf, const struct <a class="el" href="structsession__id.html">session_id</a> *sid)</td></tr>
<tr class="separator:ga03d3c93ec4c15d57947740a56eae0aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f79fac5e64e7d2a9df9bc13740f6293"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga0f79fac5e64e7d2a9df9bc13740f6293">reliable_send_purge</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel, struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *ack)</td></tr>
<tr class="separator:ga0f79fac5e64e7d2a9df9bc13740f6293"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for processing outgoing acknowledgments</h2></td></tr>
<tr class="memitem:ga6875d0fb65bdd960736068b2e0fe4a29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga6875d0fb65bdd960736068b2e0fe4a29">reliable_ack_write</a> (struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *ack, struct <a class="el" href="structbuffer.html">buffer</a> *buf, const struct <a class="el" href="structsession__id.html">session_id</a> *sid, int max, <a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> prepend)</td></tr>
<tr class="separator:ga6875d0fb65bdd960736068b2e0fe4a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for initialization and cleanup</h2></td></tr>
<tr class="memitem:gab5e5ef6d6fd862187abe76f88b972ee5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#gab5e5ef6d6fd862187abe76f88b972ee5">reliable_init</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel, int buf_size, int offset, int array_size, <a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> hold)</td></tr>
<tr class="separator:gab5e5ef6d6fd862187abe76f88b972ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0315c8ecda1aafbfb61e6ab1b8c2477b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga0315c8ecda1aafbfb61e6ab1b8c2477b">reliable_free</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel)</td></tr>
<tr class="separator:ga0315c8ecda1aafbfb61e6ab1b8c2477b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf4135caf45a800b9accff968aaa59d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#gaaf4135caf45a800b9accff968aaa59d6">reliable_ack_adjust_frame_parameters</a> (struct <a class="el" href="structframe.html">frame</a> *<a class="el" href="structframe.html">frame</a>, int max)</td></tr>
<tr class="separator:gaaf4135caf45a800b9accff968aaa59d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for inserting incoming packets</h2></td></tr>
<tr class="memitem:ga68f5e71b155cdcfabca18d028d336311"><td class="memItemLeft" align="right" valign="top"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga68f5e71b155cdcfabca18d028d336311">reliable_can_get</a> (const struct <a class="el" href="structreliable.html">reliable</a> *rel)</td></tr>
<tr class="separator:ga68f5e71b155cdcfabca18d028d336311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga907fd32837c50b4266eb5db1c56f9b13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga907fd32837c50b4266eb5db1c56f9b13">reliable_not_replay</a> (const struct <a class="el" href="structreliable.html">reliable</a> *rel, <a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a> id)</td></tr>
<tr class="separator:ga907fd32837c50b4266eb5db1c56f9b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d6e3bde9beced3d69bbba652730439"><td class="memItemLeft" align="right" valign="top"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#gad2d6e3bde9beced3d69bbba652730439">reliable_wont_break_sequentiality</a> (const struct <a class="el" href="structreliable.html">reliable</a> *rel, <a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a> id)</td></tr>
<tr class="separator:gad2d6e3bde9beced3d69bbba652730439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21a2f2e1296cea87eb6d68331667fc9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga21a2f2e1296cea87eb6d68331667fc9e">reliable_ack_read_packet_id</a> (struct <a class="el" href="structbuffer.html">buffer</a> *buf, <a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a> *pid)</td></tr>
<tr class="separator:ga21a2f2e1296cea87eb6d68331667fc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69117718f8e1e22881d957e219134ff"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#gaa69117718f8e1e22881d957e219134ff">reliable_get_buf</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel)</td></tr>
<tr class="separator:gaa69117718f8e1e22881d957e219134ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2689b44850ce41cc2fe1fc7f57657eb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga2689b44850ce41cc2fe1fc7f57657eb4">reliable_mark_active_incoming</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel, struct <a class="el" href="structbuffer.html">buffer</a> *buf, <a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a> pid, int opcode)</td></tr>
<tr class="separator:ga2689b44850ce41cc2fe1fc7f57657eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bdc89dd24741d52a2fcf8182389b947"><td class="memItemLeft" align="right" valign="top"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga3bdc89dd24741d52a2fcf8182389b947">reliable_ack_acknowledge_packet_id</a> (struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *ack, <a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a> pid)</td></tr>
<tr class="separator:ga3bdc89dd24741d52a2fcf8182389b947"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for extracting incoming packets</h2></td></tr>
<tr class="memitem:ga08f53328657f0172eb061193171e2a41"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga08f53328657f0172eb061193171e2a41">reliable_get_buf_sequenced</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel)</td></tr>
<tr class="separator:ga08f53328657f0172eb061193171e2a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c51920665fa9c34f082dd7aa6ce0e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga5c51920665fa9c34f082dd7aa6ce0e55">reliable_mark_deleted</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel, struct <a class="el" href="structbuffer.html">buffer</a> *buf, <a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> inc_pid)</td></tr>
<tr class="separator:ga5c51920665fa9c34f082dd7aa6ce0e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for inserting outgoing packets</h2></td></tr>
<tr class="memitem:gaa15b0672f4ddd65d55194ed5bde0e1c8"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#gaa15b0672f4ddd65d55194ed5bde0e1c8">reliable_get_buf_output_sequenced</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel)</td></tr>
<tr class="separator:gaa15b0672f4ddd65d55194ed5bde0e1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c03b5ae47fe72dbf4fe16f11ea1c091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga2c03b5ae47fe72dbf4fe16f11ea1c091">reliable_mark_active_outgoing</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel, struct <a class="el" href="structbuffer.html">buffer</a> *buf, int opcode)</td></tr>
<tr class="separator:ga2c03b5ae47fe72dbf4fe16f11ea1c091"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for extracting outgoing packets</h2></td></tr>
<tr class="memitem:ga79e86f7694ffbd592d944f8f45efa7c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga79e86f7694ffbd592d944f8f45efa7c8">reliable_can_send</a> (const struct <a class="el" href="structreliable.html">reliable</a> *rel)</td></tr>
<tr class="separator:ga79e86f7694ffbd592d944f8f45efa7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebcf7ae7a144f32b55c9af5c51121ec1"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#gaebcf7ae7a144f32b55c9af5c51121ec1">reliable_send</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel, int *opcode)</td></tr>
<tr class="separator:gaebcf7ae7a144f32b55c9af5c51121ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Miscellaneous functions</h2></td></tr>
<tr class="memitem:ga7e0186d08bdeb59563ce37578ee64f8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga7e0186d08bdeb59563ce37578ee64f8d">reliable_empty</a> (const struct <a class="el" href="structreliable.html">reliable</a> *rel)</td></tr>
<tr class="separator:ga7e0186d08bdeb59563ce37578ee64f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e8edfca42338da6da6ccb3fd1849dca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="common_8h.html#a3d8621f960ada51a5ad9ff181730481a">interval_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga9e8edfca42338da6da6ccb3fd1849dca">reliable_send_timeout</a> (const struct <a class="el" href="structreliable.html">reliable</a> *rel)</td></tr>
<tr class="separator:ga9e8edfca42338da6da6ccb3fd1849dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14cb4395f780502ae9edbe6d3f90aec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga14cb4395f780502ae9edbe6d3f90aec5">reliable_schedule_now</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel)</td></tr>
<tr class="separator:ga14cb4395f780502ae9edbe6d3f90aec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga864d5a93bec5ac5554ce9481d1551197"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga864d5a93bec5ac5554ce9481d1551197">reliable_debug_print</a> (const struct <a class="el" href="structreliable.html">reliable</a> *rel, char *desc)</td></tr>
<tr class="separator:ga864d5a93bec5ac5554ce9481d1551197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b9917d2ee4fe23f48f4471e8f4f4fdd"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga6b9917d2ee4fe23f48f4471e8f4f4fdd">reliable_ack_print</a> (struct <a class="el" href="structbuffer.html">buffer</a> *buf, <a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> verbose, struct <a class="el" href="structgc__arena.html">gc_arena</a> *gc)</td></tr>
<tr class="separator:ga6b9917d2ee4fe23f48f4471e8f4f4fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e35eb4bd321de7b34aa1f086451f724"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga1e35eb4bd321de7b34aa1f086451f724">reliable_ack_debug_print</a> (const struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *ack, char *desc)</td></tr>
<tr class="separator:ga1e35eb4bd321de7b34aa1f086451f724"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gacb891f0bfc023839a53a2c7005cd340c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXPONENTIAL_BACKOFF</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga91ccbc389e490d03321b1a6de0dd096d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RELIABLE_ACK_SIZE&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of packet IDs waiting to be acknowledged which can be stored in one <code><a class="el" href="structreliable__ack.html">reliable_ack</a></code> structure. </p>

</div>
</div>
<a class="anchor" id="gaa626a13dc31bf131a92548b9b2810cba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RELIABLE_CAPACITY&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of packets that the reliability layer for one VPN tunnel in one direction can store. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga3bdc89dd24741d52a2fcf8182389b947"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> reliable_ack_acknowledge_packet_id </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *&#160;</td>
          <td class="paramname"><em>ack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a>&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Record a packet ID for later acknowledgment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ack</td><td>The acknowledgment structure which stores this VPN tunnel's packet IDs for later acknowledgment. </td></tr>
    <tr><td class="paramname">pid</td><td>The packet ID of the received packet which should be acknowledged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if the packet ID was added to <em>ack</em>. </li>
<li>False, if the packet ID was already present in <em>ack</em> or <em>ack</em> has no free space to store any more packet IDs. </li>
</ul>
</dd></dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__reliable_ga3bdc89dd24741d52a2fcf8182389b947_icgraph.png" border="0" usemap="#group__reliable_ga3bdc89dd24741d52a2fcf8182389b947_icgraph" alt=""/></div>
<map name="group__reliable_ga3bdc89dd24741d52a2fcf8182389b947_icgraph" id="group__reliable_ga3bdc89dd24741d52a2fcf8182389b947_icgraph">
<area shape="rect" id="node2" href="ssl_8h.html#ad436aa1372a562e8be84491907531df4" title="tls_pre_decrypt" alt="" coords="227,13,337,39"/>
<area shape="rect" id="node3" href="forward_8h.html#a01bb4da24c0d75c32845ac87c5cad055" title="process_incoming_link\l_part1" alt="" coords="385,5,540,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaaf4135caf45a800b9accff968aaa59d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_ack_adjust_frame_parameters </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structframe.html">frame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1e35eb4bd321de7b34aa1f086451f724"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_ack_debug_print </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *&#160;</td>
          <td class="paramname"><em>ack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6b9917d2ee4fe23f48f4471e8f4f4fdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* reliable_ack_print </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structgc__arena.html">gc_arena</a> *&#160;</td>
          <td class="paramname"><em>gc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__reliable_ga6b9917d2ee4fe23f48f4471e8f4f4fdd_cgraph.png" border="0" usemap="#group__reliable_ga6b9917d2ee4fe23f48f4471e8f4f4fdd_cgraph" alt=""/></div>
<map name="group__reliable_ga6b9917d2ee4fe23f48f4471e8f4f4fdd_cgraph" id="group__reliable_ga6b9917d2ee4fe23f48f4471e8f4f4fdd_cgraph">
<area shape="rect" id="node2" href="buffer_8c.html#aa35bf7feb6a99bf5d364b2d4eba1195c" title="alloc_buf_gc" alt="" coords="187,31,281,57"/>
<area shape="rect" id="node5" href="buffer_8c.html#a3307f08331b1ce42168bafd2ecf7874a" title="buf_printf" alt="" coords="197,81,271,108"/>
<area shape="rect" id="node6" href="session__id_8c.html#aa7884bbdd976e0582af7ce08249a5688" title="session_id_print" alt="" coords="176,132,292,159"/>
<area shape="rect" id="node3" href="buffer_8c.html#acc1a4ee83a591116d331e52baacf253d" title="buf_size_error" alt="" coords="340,5,443,32"/>
<area shape="rect" id="node4" href="buffer_8c.html#a67f7dec7f86e113dc0744584fd80b621" title="gc_malloc" alt="" coords="351,56,432,83"/>
</map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__reliable_ga6b9917d2ee4fe23f48f4471e8f4f4fdd_icgraph.png" border="0" usemap="#group__reliable_ga6b9917d2ee4fe23f48f4471e8f4f4fdd_icgraph" alt=""/></div>
<map name="group__reliable_ga6b9917d2ee4fe23f48f4471e8f4f4fdd_icgraph" id="group__reliable_ga6b9917d2ee4fe23f48f4471e8f4f4fdd_icgraph">
<area shape="rect" id="node2" href="ssl_8h.html#a942946896996b3be347482cfea59c478" title="protocol_dump" alt="" coords="176,5,283,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga03d3c93ec4c15d57947740a56eae0aec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> reliable_ack_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *&#160;</td>
          <td class="paramname"><em>ack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsession__id.html">session_id</a> *&#160;</td>
          <td class="paramname"><em>sid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read an acknowledgment record from a received packet.</p>
<p>This function reads the packet ID acknowledgment record from the packet contained in <em>buf</em>. If the record contains acknowledgments, these are stored in <em>ack</em>. This function also compares the packet's session ID with the expected session ID <em>sid</em>, which should be equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ack</td><td>The acknowledgment structure in which received acknowledgments are to be stored. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer containing the packet. </td></tr>
    <tr><td class="paramname">sid</td><td>The expected session ID to compare to the session ID in the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if processing was successful. </li>
<li>False, if an error occurs during processing. </li>
</ul>
</dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__reliable_ga03d3c93ec4c15d57947740a56eae0aec_cgraph.png" border="0" usemap="#group__reliable_ga03d3c93ec4c15d57947740a56eae0aec_cgraph" alt=""/></div>
<map name="group__reliable_ga03d3c93ec4c15d57947740a56eae0aec_cgraph" id="group__reliable_ga03d3c93ec4c15d57947740a56eae0aec_cgraph">
<area shape="rect" id="node2" href="session__id_8c.html#aa7884bbdd976e0582af7ce08249a5688" title="session_id_print" alt="" coords="176,5,292,32"/>
</map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__reliable_ga03d3c93ec4c15d57947740a56eae0aec_icgraph.png" border="0" usemap="#group__reliable_ga03d3c93ec4c15d57947740a56eae0aec_icgraph" alt=""/></div>
<map name="group__reliable_ga03d3c93ec4c15d57947740a56eae0aec_icgraph" id="group__reliable_ga03d3c93ec4c15d57947740a56eae0aec_icgraph">
<area shape="rect" id="node2" href="ssl_8h.html#ad436aa1372a562e8be84491907531df4" title="tls_pre_decrypt" alt="" coords="176,13,287,39"/>
<area shape="rect" id="node3" href="forward_8h.html#a01bb4da24c0d75c32845ac87c5cad055" title="process_incoming_link\l_part1" alt="" coords="335,5,489,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga21a2f2e1296cea87eb6d68331667fc9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> reliable_ack_read_packet_id </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a> *&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the packet ID of a received packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer containing the received packet. </td></tr>
    <tr><td class="paramname">pid</td><td>A pointer where the packet's packet ID will be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if processing was successful. </li>
<li>False, if an error occurs during processing. </li>
</ul>
</dd></dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__reliable_ga21a2f2e1296cea87eb6d68331667fc9e_icgraph.png" border="0" usemap="#group__reliable_ga21a2f2e1296cea87eb6d68331667fc9e_icgraph" alt=""/></div>
<map name="group__reliable_ga21a2f2e1296cea87eb6d68331667fc9e_icgraph" id="group__reliable_ga21a2f2e1296cea87eb6d68331667fc9e_icgraph">
<area shape="rect" id="node2" href="ssl_8h.html#ad436aa1372a562e8be84491907531df4" title="tls_pre_decrypt" alt="" coords="240,13,351,39"/>
<area shape="rect" id="node3" href="forward_8h.html#a01bb4da24c0d75c32845ac87c5cad055" title="process_incoming_link\l_part1" alt="" coords="399,5,553,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga6875d0fb65bdd960736068b2e0fe4a29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> reliable_ack_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *&#160;</td>
          <td class="paramname"><em>ack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsession__id.html">session_id</a> *&#160;</td>
          <td class="paramname"><em>sid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>prepend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a packet ID acknowledgment record to a buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ack</td><td>The acknowledgment structure containing packet IDs to be acknowledged. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer into which the acknowledgment record will be written. </td></tr>
    <tr><td class="paramname">sid</td><td>The session ID of the VPN tunnel associated with the packet IDs to be acknowledged. </td></tr>
    <tr><td class="paramname">max</td><td>The maximum number of acknowledgments to be written in the record. </td></tr>
    <tr><td class="paramname">prepend</td><td>If true, prepend the acknowledgment record in the buffer; if false, write into the buffer's current position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if processing was successful. </li>
<li>False, if an error occurs during processing. </li>
</ul>
</dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__reliable_ga6875d0fb65bdd960736068b2e0fe4a29_cgraph.png" border="0" usemap="#group__reliable_ga6875d0fb65bdd960736068b2e0fe4a29_cgraph" alt=""/></div>
<map name="group__reliable_ga6875d0fb65bdd960736068b2e0fe4a29_cgraph" id="group__reliable_ga6875d0fb65bdd960736068b2e0fe4a29_cgraph">
<area shape="rect" id="node2" href="buffer_8c.html#a5c9b9840112ac21bbadae88170cf89df" title="buf_sub" alt="" coords="179,5,245,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga68f5e71b155cdcfabca18d028d336311"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> reliable_can_get </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether a reliable structure has any free buffers available for use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if at least one buffer is available for use. </li>
<li>False, if all the buffers are active. </li>
</ul>
</dd></dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__reliable_ga68f5e71b155cdcfabca18d028d336311_icgraph.png" border="0" usemap="#group__reliable_ga68f5e71b155cdcfabca18d028d336311_icgraph" alt=""/></div>
<map name="group__reliable_ga68f5e71b155cdcfabca18d028d336311_icgraph" id="group__reliable_ga68f5e71b155cdcfabca18d028d336311_icgraph">
<area shape="rect" id="node2" href="ssl_8h.html#ad436aa1372a562e8be84491907531df4" title="tls_pre_decrypt" alt="" coords="169,13,280,39"/>
<area shape="rect" id="node3" href="forward_8h.html#a01bb4da24c0d75c32845ac87c5cad055" title="process_incoming_link\l_part1" alt="" coords="328,5,483,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga79e86f7694ffbd592d944f8f45efa7c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> reliable_can_send </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether a reliable structure has any active entries ready to be (re)sent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if there are active entries ready to be (re)sent president. </li>
<li>False, if there are no active entries, or the active entries are not yet ready for resending. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga864d5a93bec5ac5554ce9481d1551197"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_debug_print </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7e0186d08bdeb59563ce37578ee64f8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> reliable_empty </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether a reliable structure is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if there are no active entries in the given reliable structure. </li>
<li>False, if there is at least one active entry present. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0315c8ecda1aafbfb61e6ab1b8c2477b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free allocated memory associated with a reliable structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structured to clean up. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__reliable_ga0315c8ecda1aafbfb61e6ab1b8c2477b_cgraph.png" border="0" usemap="#group__reliable_ga0315c8ecda1aafbfb61e6ab1b8c2477b_cgraph" alt=""/></div>
<map name="group__reliable_ga0315c8ecda1aafbfb61e6ab1b8c2477b_cgraph" id="group__reliable_ga0315c8ecda1aafbfb61e6ab1b8c2477b_cgraph">
<area shape="rect" id="node2" href="buffer_8c.html#a11cd36c0af3073bd1245bbed1cca9590" title="free_buf" alt="" coords="144,5,211,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaa69117718f8e1e22881d957e219134ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbuffer.html">buffer</a>* reliable_get_buf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the buffer of a free reliable entry in which to store a packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure in which to search for a free entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a buffer of a free entry in the <em>rel</em> reliable structure. If there are no free entries available, this function returns NULL. </dd></dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__reliable_gaa69117718f8e1e22881d957e219134ff_icgraph.png" border="0" usemap="#group__reliable_gaa69117718f8e1e22881d957e219134ff_icgraph" alt=""/></div>
<map name="group__reliable_gaa69117718f8e1e22881d957e219134ff_icgraph" id="group__reliable_gaa69117718f8e1e22881d957e219134ff_icgraph">
<area shape="rect" id="node2" href="group__reliable.html#gaa15b0672f4ddd65d55194ed5bde0e1c8" title="reliable_get_buf_output\l_sequenced" alt="" coords="165,5,320,47"/>
<area shape="rect" id="node3" href="ssl_8h.html#ad436aa1372a562e8be84491907531df4" title="tls_pre_decrypt" alt="" coords="187,71,298,98"/>
<area shape="rect" id="node4" href="forward_8h.html#a01bb4da24c0d75c32845ac87c5cad055" title="process_incoming_link\l_part1" alt="" coords="368,64,523,105"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaa15b0672f4ddd65d55194ed5bde0e1c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbuffer.html">buffer</a>* reliable_get_buf_output_sequenced </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the buffer of free reliable entry and check whether the outgoing acknowledgment sequence is still okay.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure in which to search for a free entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a buffer of a free entry in the <em>rel</em> reliable structure. If there are no free entries available, this function returns NULL. If the outgoing acknowledgment sequence is broken, this function also returns NULL. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__reliable_gaa15b0672f4ddd65d55194ed5bde0e1c8_cgraph.png" border="0" usemap="#group__reliable_gaa15b0672f4ddd65d55194ed5bde0e1c8_cgraph" alt=""/></div>
<map name="group__reliable_gaa15b0672f4ddd65d55194ed5bde0e1c8_cgraph" id="group__reliable_gaa15b0672f4ddd65d55194ed5bde0e1c8_cgraph">
<area shape="rect" id="node2" href="group__reliable.html#gaa69117718f8e1e22881d957e219134ff" title="reliable_get_buf" alt="" coords="208,13,320,39"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga08f53328657f0172eb061193171e2a41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbuffer.html">buffer</a>* reliable_get_buf_sequenced </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the buffer of the next sequential and active entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure from which to retrieve the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the buffer of the entry with the next sequential key ID. If no such entry is present, this function returns NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="gab5e5ef6d6fd862187abe76f88b972ee5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>array_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>hold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a reliable structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure to initialize. </td></tr>
    <tr><td class="paramname">buf_size</td><td>The size of the buffers in which packets will be stored. </td></tr>
    <tr><td class="paramname">offset</td><td>The size of reserved space at the beginning of the buffers to allow efficient header prepending. </td></tr>
    <tr><td class="paramname">array_size</td><td>The number of packets that this reliable structure can store simultaneously. </td></tr>
    <tr><td class="paramname">hold</td><td>description </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__reliable_gab5e5ef6d6fd862187abe76f88b972ee5_cgraph.png" border="0" usemap="#group__reliable_gab5e5ef6d6fd862187abe76f88b972ee5_cgraph" alt=""/></div>
<map name="group__reliable_gab5e5ef6d6fd862187abe76f88b972ee5_cgraph" id="group__reliable_gab5e5ef6d6fd862187abe76f88b972ee5_cgraph">
<area shape="rect" id="node2" href="buffer_8c.html#aa6bae12914d41c7aecaa7b64fea1bc51" title="alloc_buf" alt="" coords="140,5,213,32"/>
<area shape="rect" id="node3" href="buffer_8c.html#acc1a4ee83a591116d331e52baacf253d" title="buf_size_error" alt="" coords="261,5,364,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga2689b44850ce41cc2fe1fc7f57657eb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_mark_active_incoming </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a>&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark the reliable entry associated with the given buffer as active incoming.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure associated with this packet. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer into which the packet has been copied. </td></tr>
    <tr><td class="paramname">pid</td><td>The packet's packet ID. </td></tr>
    <tr><td class="paramname">opcode</td><td>The packet's opcode. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__reliable_ga2689b44850ce41cc2fe1fc7f57657eb4_icgraph.png" border="0" usemap="#group__reliable_ga2689b44850ce41cc2fe1fc7f57657eb4_icgraph" alt=""/></div>
<map name="group__reliable_ga2689b44850ce41cc2fe1fc7f57657eb4_icgraph" id="group__reliable_ga2689b44850ce41cc2fe1fc7f57657eb4_icgraph">
<area shape="rect" id="node2" href="ssl_8h.html#ad436aa1372a562e8be84491907531df4" title="tls_pre_decrypt" alt="" coords="192,13,303,39"/>
<area shape="rect" id="node3" href="forward_8h.html#a01bb4da24c0d75c32845ac87c5cad055" title="process_incoming_link\l_part1" alt="" coords="351,5,505,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga2c03b5ae47fe72dbf4fe16f11ea1c091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_mark_active_outgoing </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark the reliable entry associated with the given buffer as active outgoing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure for handling this VPN tunnel's outgoing packets. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer previously returned by <code><a class="el" href="group__reliable.html#gaa15b0672f4ddd65d55194ed5bde0e1c8">reliable_get_buf_output_sequenced()</a></code> into which the packet has been copied. </td></tr>
    <tr><td class="paramname">opcode</td><td>The packet's opcode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5c51920665fa9c34f082dd7aa6ce0e55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_mark_deleted </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>inc_pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an entry from a reliable structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure associated with the given buffer. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer of the reliable entry which is to be removed. </td></tr>
    <tr><td class="paramname">inc_pid</td><td>If true, the reliable structure's packet ID counter will be incremented. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga907fd32837c50b4266eb5db1c56f9b13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> reliable_not_replay </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check that a received packet's ID is not a replay.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure for handling this VPN tunnel's received packets. </td></tr>
    <tr><td class="paramname">id</td><td>The packet ID of the received packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if the packet ID is not a replay. </li>
<li>False, if the packet ID is a replay. </li>
</ul>
</dd></dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__reliable_ga907fd32837c50b4266eb5db1c56f9b13_icgraph.png" border="0" usemap="#group__reliable_ga907fd32837c50b4266eb5db1c56f9b13_icgraph" alt=""/></div>
<map name="group__reliable_ga907fd32837c50b4266eb5db1c56f9b13_icgraph" id="group__reliable_ga907fd32837c50b4266eb5db1c56f9b13_icgraph">
<area shape="rect" id="node2" href="ssl_8h.html#ad436aa1372a562e8be84491907531df4" title="tls_pre_decrypt" alt="" coords="184,13,295,39"/>
<area shape="rect" id="node3" href="forward_8h.html#a01bb4da24c0d75c32845ac87c5cad055" title="process_incoming_link\l_part1" alt="" coords="343,5,497,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga14cb4395f780502ae9edbe6d3f90aec5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_schedule_now </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reschedule all entries of a reliable structure to be ready for (re)sending immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure of which the entries should be modified. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__reliable_ga14cb4395f780502ae9edbe6d3f90aec5_icgraph.png" border="0" usemap="#group__reliable_ga14cb4395f780502ae9edbe6d3f90aec5_icgraph" alt=""/></div>
<map name="group__reliable_ga14cb4395f780502ae9edbe6d3f90aec5_icgraph" id="group__reliable_ga14cb4395f780502ae9edbe6d3f90aec5_icgraph">
<area shape="rect" id="node2" href="ssl_8h.html#ad436aa1372a562e8be84491907531df4" title="tls_pre_decrypt" alt="" coords="205,13,316,39"/>
<area shape="rect" id="node3" href="forward_8h.html#a01bb4da24c0d75c32845ac87c5cad055" title="process_incoming_link\l_part1" alt="" coords="364,5,519,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaebcf7ae7a144f32b55c9af5c51121ec1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbuffer.html">buffer</a>* reliable_send </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>opcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the next packet to send to the remote peer.</p>
<p>This function looks for the active entry ready for (re)sending with the lowest packet ID, and returns the buffer associated with it. This function also resets the timeout after which that entry will become ready for resending again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure to check. </td></tr>
    <tr><td class="paramname">opcode</td><td>A pointer to an integer in which this function will store the opcode of the next packet to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the buffer of the next entry to be sent, or NULL if there are no entries ready for (re)sending present in the reliable structure. If a valid pointer is returned, then <em>opcode</em> will point to the opcode of that packet. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0f79fac5e64e7d2a9df9bc13740f6293"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_send_purge </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *&#160;</td>
          <td class="paramname"><em>ack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove acknowledged packets from a reliable structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure storing sent packets. </td></tr>
    <tr><td class="paramname">ack</td><td>The acknowledgment structure containing received acknowledgments. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__reliable_ga0f79fac5e64e7d2a9df9bc13740f6293_icgraph.png" border="0" usemap="#group__reliable_ga0f79fac5e64e7d2a9df9bc13740f6293_icgraph" alt=""/></div>
<map name="group__reliable_ga0f79fac5e64e7d2a9df9bc13740f6293_icgraph" id="group__reliable_ga0f79fac5e64e7d2a9df9bc13740f6293_icgraph">
<area shape="rect" id="node2" href="ssl_8h.html#ad436aa1372a562e8be84491907531df4" title="tls_pre_decrypt" alt="" coords="191,13,301,39"/>
<area shape="rect" id="node3" href="forward_8h.html#a01bb4da24c0d75c32845ac87c5cad055" title="process_incoming_link\l_part1" alt="" coords="349,5,504,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga9e8edfca42338da6da6ccb3fd1849dca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_8h.html#a3d8621f960ada51a5ad9ff181730481a">interval_t</a> reliable_send_timeout </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determined how many seconds until the earliest resend should be attempted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structured to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interval in seconds until the earliest resend attempt of the outgoing packets stored in the <em>rel</em> reliable structure. If the next time for attempting resending of one or more packets has already passed, this function will return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="gad2d6e3bde9beced3d69bbba652730439"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="automatic_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> reliable_wont_break_sequentiality </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check that a received packet's ID can safely be stored in the reliable structure's processing window.</p>
<p>This function checks the difference between the received packet's ID and the lowest non-acknowledged packet ID in the given reliable structure. If that difference is larger than the total number of packets which can be stored, then this packet cannot be stored safely, because the reliable structure could possibly fill up without leaving room for all intervening packets. In that case, this received packet could break the reliable structure's sequentiality, and must therefore be discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure for handling this VPN tunnel's received packets. </td></tr>
    <tr><td class="paramname">id</td><td>The packet ID of the received packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if the packet can safely be stored. </li>
<li>False, if the packet does not fit safely in the reliable structure's processing window. </li>
</ul>
</dd></dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__reliable_gad2d6e3bde9beced3d69bbba652730439_icgraph.png" border="0" usemap="#group__reliable_gad2d6e3bde9beced3d69bbba652730439_icgraph" alt=""/></div>
<map name="group__reliable_gad2d6e3bde9beced3d69bbba652730439_icgraph" id="group__reliable_gad2d6e3bde9beced3d69bbba652730439_icgraph">
<area shape="rect" id="node2" href="ssl_8h.html#ad436aa1372a562e8be84491907531df4" title="tls_pre_decrypt" alt="" coords="189,13,300,39"/>
<area shape="rect" id="node3" href="forward_8h.html#a01bb4da24c0d75c32845ac87c5cad055" title="process_incoming_link\l_part1" alt="" coords="348,5,503,47"/>
</map>
</div>
</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
